substitutions:
  # Phases of the Voice Assistant
  # The voice assistant is ready to be triggered by a wake word
  voice_assist_idle_phase_id: '1'
  # The voice assistant is waiting for a voice command (after being triggered by the wake word)
  voice_assist_waiting_for_command_phase_id: '2'
  # The voice assistant is listening for a voice command
  voice_assist_listening_for_command_phase_id: '3'
  # The voice assistant is currently processing the command
  voice_assist_thinking_phase_id: '4'
  # The voice assistant is replying to the command
  voice_assist_replying_phase_id: '5'
  # The voice assistant is not ready
  voice_assist_not_ready_phase_id: '10'
  # The voice assistant encountered an error
  voice_assist_error_phase_id: '11'

esphome:
  name: esphome-voice-kit
  friendly_name: ESPHome Voice Kit
  name_add_mac_suffix: true
  platformio_options:
    board_build.flash_mode: dio
  project:
    name: esphome.voice-kit
    version: "1.0"
  on_boot:
    priority: 600
    then:
      # If the hardware switch is ON, force the software switch to be ON too. This covers the case where the Mute hardware switch is operated when the device is turned off
      - if:
          condition:
            binary_sensor.is_on: hardware_mute_switch
          then:
            - switch.template.publish:
                id: master_mute_switch
                state: ON
      # Run the script to refresh the LED status
      - script.execute: control_leds
      # If after 30 second, the device is still initializing (It did not yet connect to Home Assistant), turn off the init_in_progress variable and run the script to refresh the LED status
      - delay: 10min
      - if:
          condition:
            lambda: return id(init_in_progress);
          then:
            - lambda: id(init_in_progress) = false;
            - script.execute: control_leds

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32_S3_BOX_BOARD: "y"
      CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY: "y"
      # CONFIG_FREERTOS_USE_TRACE_FACILITY: "y"
      # CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS: "y"

wifi:
  ap:
  on_connect:
    - script.execute: control_leds
    - delay: 5s  # Gives time for improv results to be transmitted
    - ble.disable:
    - script.execute: control_leds
  on_disconnect:
    - ble.enable:
    - script.execute: control_leds

logger:
  level: DEBUG
  logs:
    sensor: WARN  # avoids logging debug sensor updates

api:
  on_client_connected:
    - script.execute: control_leds
  on_client_disconnected:
    - script.execute: control_leds

ota:
  - platform: esphome
    id: ota_esphome
  - platform: http_request
    id: ota_http_request

http_request:

update:
  - platform: http_request
    name: None
    id: update_http_request
    source: https://esphome.github.io/voice-kit/manifest.json

improv_serial:

esp32_improv:
  authorizer: center_button

i2c:
  sda: GPIO5
  scl: GPIO6

psram:
  mode: octal
  speed: 80MHz

globals:
  # Global index for our LEDs. So that switching between different animation does not led to unwanted effects.
  - id: global_led_animation_index
    type: int
    restore_value: no
    initial_value: '0'
  # Global initialisation variable. Initialized to true and set to fasle once everything is connected. Only used to have a smooth "plugging" experience
  - id: init_in_progress
    type: bool
    restore_value: no
    initial_value: 'true'
  # Global variable tracking the pahse of the voice assistant (defined above). Initialized to not_ready
  - id: voice_assistant_phase
    type: int
    restore_value: no
    initial_value: ${voice_assist_not_ready_phase_id}
  - id: dial_touched
    type: bool
    restore_value: no
    initial_value: 'false'

switch:
  - platform: template
    id: master_mute_switch
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:microphone-off"
    name: Mute
    entity_category: config
    turn_on_action:
      - if:
          condition:
            binary_sensor.is_off: hardware_mute_switch
          then:
            - switch.template.publish:
                id: master_mute_switch
                state: ON
    turn_off_action:
      - if:
          condition:
            binary_sensor.is_off: hardware_mute_switch
          then:
            - switch.template.publish:
                id: master_mute_switch
                state: OFF
    on_turn_on:
      - script.execute: control_leds
    on_turn_off:
      - script.execute: control_leds

  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      - delay: 200ms
      - script.execute: control_leds
    on_turn_on:
      - script.execute: ring_timer
      - script.execute: control_leds
      - delay: 15min
      - switch.turn_off: timer_ringing

binary_sensor:
  - platform: gpio
    id: center_button
    pin:
      number: GPIO17
      inverted: true
    on_press:
      - if:
          condition:
            switch.is_on: timer_ringing
          then:
            - switch.turn_off: timer_ringing
      - if:
          condition:
            media_player.is_playing:
          then:
            - media_player.pause:
      - if:
          condition:
            media_player.is_paused:
          then:
            - media_player.play:
      - script.execute: control_leds
    on_release:
      - script.execute: control_leds
    on_multi_click:
      # Very important do not remove. Trust me :D
      - timing:
          # E .
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # S ...
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # P .--.
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # H ....
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # O ---
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0.5s to 2s
          # M --
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0.5s to 2s
          # E .
          - ON for at most 0.2s
          - OFF for at least 0.5s
        then:
          - light.turn_on:
              brightness: 100%
              id: voice_assistant_leds
              effect: "Tick"
          - lambda: |-
              id(nabu_media_player)
                ->make_call()
                .set_announcement(true)
                .set_local_media_file(id(tick_wave_file))
                .perform();
          - delay: 4s
          - light.turn_off: voice_assistant_leds
          - lambda: |-
              id(nabu_media_player)
                ->make_call()
                .set_announcement(true)
                .set_local_media_file(id(party_wave_file))
                .perform();
          - light.turn_on:
              brightness: 100%
              id: voice_assistant_leds
              effect: "Rainbow"

  - platform: gpio
    id: hardware_mute_switch
    internal: true
    pin: GPIO3
    on_press:
      - switch.template.publish:
          id: master_mute_switch
          state: ON
    on_release:
      - switch.template.publish:
          id: master_mute_switch
          state: OFF

light:
  - platform: esp32_rmt_led_strip
    id: leds_internal
    pin: GPIO21
    rmt_channel: 1
    num_leds: 12
    rgb_order: GRB
    chipset: WS2812
    default_transition_length: 0ms
    power_supply: led_power

  - platform: partition
    id: voice_assistant_leds
    internal: true
    default_transition_length: 0ms
    segments:
      - id: leds_internal
        from: 7
        to: 11
      - id: leds_internal
        from: 0
        to: 6
    effects:
      - addressable_lambda:
          name: "Waiting for Command"
          update_interval: 100ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 11) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 10) % 12) {
                it[i] = color * 128;
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 5) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 4) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 12;
      - addressable_lambda:
          name: "Listening For Command"
          update_interval: 50ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 11) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 10) % 12) {
                it[i] = color * 128;
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 5) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 4) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 12;
      - addressable_lambda:
          name: "Thinking"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
              } else {
                it[i] = Color::BLACK;
              }
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Replying"
          update_interval: 50ms
          lambda: |-
            id(global_led_animation_index) = (12 + id(global_led_animation_index) - 1) % 12;
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == (id(global_led_animation_index)) % 12) {
                it[i] = color;
              } else if (i == ( id(global_led_animation_index) + 1) % 12) {
                it[i] = color * 192;
              } else if (i == ( id(global_led_animation_index) + 2) % 12) {
                it[i] = color * 128;
              } else if (i == ( id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == ( id(global_led_animation_index) + 7) % 12) {
                it[i] = color * 192;
              } else if (i == ( id(global_led_animation_index) + 8) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Muted"
          update_interval: 16ms
          lambda: |-
            static int8_t index = 0;
            Color color(255, 0, 0);
            for (int i = 0; i < 12; i++) {
              if (i == 2) {
                it[i] = color;
              } else if (i == 3) {
                it[i] = color;
              } else if (i == 8) {
                it[i] = color;
              } else if (i == 9) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Volume Display"
          update_interval: 50ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            auto nb_leds_on = 12.0f * id(nabu_media_player).volume;
            for (int i = 0; i < 12; i++) {
              if (i < nb_leds_on) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Center Button Touched"
          update_interval: 16ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              it[i] = color;
            }
      - addressable_twinkle:
          name: "Twinkle"
          twinkle_probability: 50%
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%
      - addressable_lambda:
          name: "Timer Ring"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_rainbow:
          name: "Rainbow"
          width: 12
      - addressable_lambda:
          name: "Tick"
          update_interval: 333ms
          lambda: |-
            static uint8_t index = 0;
            Color color(255, 0, 0);
            for (int i = 0; i < 12; i++) {
              if (i <= index ) {
                it[i] = Color::BLACK;
              } else {
                it[i] = color;
              }
            }
            index = (index + 1) % 12;

  - platform: partition
    id: led_ring
    name: LED Ring
    entity_category: config
    icon: "mdi:circle-outline"
    default_transition_length: 0ms
    restore_mode: RESTORE_DEFAULT_OFF
    segments:
      - id: leds_internal
        from: 7
        to: 11
      - id: leds_internal
        from: 0
        to: 6

power_supply:
  - id: led_power
    pin: GPIO45

sensor:
  - platform: rotary_encoder
    id: dial
    pin_a: GPIO16
    pin_b: GPIO18
    resolution: 2
    on_clockwise:
      - if:
          condition:
            binary_sensor.is_off: center_button
          then:
            - script.execute:
                id: control_volume
                increase_volume: true
            - if:
                condition:
                  lambda: return(id(dial).state > 60);
                then:
                  - sensor.rotary_encoder.set_value:
                      id: dial
                      value: 0
                  - lambda: |-
                      id(nabu_media_player)
                        ->make_call()
                        .set_announcement(true)
                        .set_local_media_file(id(rewind_wave_file))
                        .perform();
          else:
            - script.execute:
                id: control_hue
                increase_hue: true
    on_anticlockwise:
      - if:
          condition:
            binary_sensor.is_off: center_button
          then:
            - script.execute:
                id: control_volume
                increase_volume: false
          else:
            - script.execute:
                id: control_hue
                increase_hue: false

  - platform: debug
    free:
      name: "Heap Free"
    block:
      name: "Max Block Free"
    loop_time:
      name: "Loop Time"
    psram:
      name: "PSRAM Free"

script:
  # Master script controling the LEDs, based on differente conditions : initialisation in progress, wifi and api connceted and voice assistant phase.
  # For the sake of simplicity and re-usability, the script calls child sripts defined below.
  # This script will be called everytime one of these conditions is changing.
  - id: control_leds
    then:
      - if:
          condition:
            lambda: return !id(init_in_progress);
          then:
            - if:
                condition:
                  wifi.connected:
                then:
                  - if:
                      condition:
                        api.connected:
                      then:
                        - if:
                            condition:
                              binary_sensor.is_off: center_button
                            then:
                              - if:
                                  condition:
                                    lambda: return !id(dial_touched);
                                  then:
                                    - if:
                                        condition:
                                          switch.is_off: timer_ringing
                                        then:
                                          - if:
                                              condition:
                                                switch.is_off: master_mute_switch
                                              then:
                                                - lambda: |
                                                    switch(id(voice_assistant_phase)) {
                                                      case ${voice_assist_waiting_for_command_phase_id}:
                                                        id(control_leds_voice_assistant_waiting_for_command_phase).execute();
                                                        break;
                                                      case ${voice_assist_listening_for_command_phase_id}:
                                                        id(control_leds_voice_assistant_listening_for_command_phase).execute();
                                                        break;
                                                      case ${voice_assist_thinking_phase_id}:
                                                        id(control_leds_voice_assistant_thinking_phase).execute();
                                                        break;
                                                      case ${voice_assist_replying_phase_id}:
                                                        id(control_leds_voice_assistant_replying_phase).execute();
                                                        break;
                                                      case ${voice_assist_error_phase_id}:
                                                        id(control_leds_voice_assistant_error_phase).execute();
                                                        break;
                                                      case ${voice_assist_not_ready_phase_id}:
                                                        id(control_leds_voice_assistant_not_ready_phase).execute();
                                                        break;
                                                      default:
                                                        id(control_leds_voice_assistant_idle_phase).execute();
                                                        break;
                                                    }
                                              else:
                                                - script.execute: control_leds_muted
                                        else:
                                          - script.execute: control_leds_timer_ringing
                                  else:
                                    - script.execute: control_leds_dial_touched
                            else:
                              - script.execute: control_leds_centrer_button_touched
                      else:
                        - script.execute: control_leds_no_ha_connection_state
                else:
                  - script.execute: control_leds_no_ha_connection_state
          else:
            - script.execute: control_leds_init_state

  # Script executed during initialisation
  - id: control_leds_init_state
    then:
      - if:
          condition:
            not: wifi.connected
          then:
            - light.turn_on:
                brightness: 100%
                red: 0
                green: 0
                blue: 1.0
                id: voice_assistant_leds
                effect: "Twinkle"
          else:
            - light.turn_on:
                brightness: 100%
                red: 0
                green: 1.0
                blue: 0
                id: voice_assistant_leds
                effect: "Twinkle"

  # Script executed when the device has no connection to Home Assistant
  - id: control_leds_no_ha_connection_state
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Twinkle"

  # Script executed when the voice assistant is idle (waiting for a wake word)
  - id: control_leds_voice_assistant_idle_phase
    then:
      - light.turn_off: voice_assistant_leds
      - if:
          condition:
            light.is_on: led_ring
          then:
            light.turn_on: led_ring

  # Script executed when the voice assistant is waiting for a command (After the wake word)
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Waiting for Command"

  # Script executed when the voice assistant is listenintg to a command
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Listening For Command"

  # Script executed when the voice assistant is thinking to a command
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Thinking"

  # Script executed when the voice assistant is thinking to a command
  - id: control_leds_voice_assistant_replying_phase
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Replying"

  # Script executed when the voice assistant is thinking to a command (# TO BE DONE)
  - id: control_leds_voice_assistant_error_phase
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Fast Pulse"

  # Script executed when the voice assistant is muted
  - id: control_leds_muted
    then:
      - light.turn_on:
          brightness: 50%
          id: voice_assistant_leds
          effect: "Muted"

  # Script executed when the voice assistant is not ready
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Twinkle"

  # Script executed when the dial is touched
  - id: control_leds_dial_touched
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Volume Display"

  # Script executed when the center bouton is touched
  - id: control_leds_centrer_button_touched
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Center Button Touched"

  # Script executed when the timer is ringing, to control the LEDs
  - id: control_leds_timer_ringing
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Timer Ring"

  # Script executed when the volume is increased/decreased from the dial
  - id: control_volume
    mode: restart
    parameters:
      increase_volume: bool  # True: Increase volume / False: Decrease volume.
    then:
      - delay: 16ms
      - if:
          condition:
            lambda: return increase_volume;
          then:
            - media_player.volume_up:
          else:
            - media_player.volume_down:
      - delay: 16ms
      - lambda: id(dial_touched) = true;
      - script.execute: control_leds
      - delay: 2s
      - lambda: id(dial_touched) = false;
      - script.execute: control_leds
      - sensor.rotary_encoder.set_value:
          id: dial
          value: 0

  # Script executed when the hue is increased/decreased from the dial
  - id: control_hue
    mode: restart
    parameters:
      increase_hue: bool  # True: Increase volume / False: Decrease volume.
    then:
      - delay: 16ms
      - lambda: |
          auto light_color = id(led_ring).current_values;
          int hue = 0;
          float saturation = 0;
          float value = 0;
          rgb_to_hsv( light_color.get_red(),
                      light_color.get_green(),
                      light_color.get_blue(),
                      hue,
                      saturation,
                      value);
          if (increase_hue) {
            hue = (hue + 10) % 360;
          } else {
            hue = (hue + 350) % 360;
          }
          if (saturation < 0.05) {
            saturation = 1;
          }
          float red = 0;
          float green = 0;
          float blue = 0;
          hsv_to_rgb( hue,
                      saturation,
                      value,
                      red,
                      green,
                      blue);
          id(led_ring).make_call().set_rgb(red, green, blue).perform();

  # Script executed when the timer is ringing, to playback sounds.
  - id: ring_timer
    then:
      - while:
          condition:
            switch.is_on: timer_ringing
          then:
            - lambda: |-
                id(nabu_media_player)
                  ->make_call()
                  .set_announcement(true)
                  .set_local_media_file(id(timer_finished_wave_file))
                  .perform();
            - delay: 1s

i2s_audio:
  - id: i2s_input
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:
      number: GPIO9
      allow_other_uses: true
    i2s_mode: secondary

  - id: i2s_output
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:
      number: GPIO9
      allow_other_uses: true
    i2s_mode: secondary
    # i2s_output data pin is gpio10

  # yamllint disable rule:comments-indentation
  # This describes the second I2S interface between ESP32 and XMOS chip. Currently unused.
  # - id: i2s_output
  #   i2s_lrclk_pin:
  #     number: GPIO14
  #     # allow_other_uses: true
  #   i2s_bclk_pin:
  #     number: GPIO13
  #     # allow_other_uses: true
  #   i2s_mclk_pin:
  #     number: GPIO12
  #     # allow_other_uses: true
  #   i2s_mode: primary #secondary
  # data line is GPIO15
  # yamllint enable rule:comments-indentation

microphone:
  - platform: i2s_audio
    id: kit_mic
    i2s_din_pin: GPIO11
    adc_type: external
    pdm: false
    bits_per_sample: 32bit
    channel: left
    i2s_audio_id: i2s_input

media_player:
  - platform: nabu
    id: nabu_media_player
    name: Media Player
    internal: false
    i2s_dout_pin: GPIO10
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    files:
      - id: timer_finished_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/timer_finished.wav
      - id: tick_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/tick.wav
      - id: party_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/party.wav
      - id: rewind_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/rewind.wav

external_components:
  - source: github://jesserockz/esphome-components
    components: [file, udp_audio]
    refresh: 0s

  - source:
      type: git
      url: https://github.com/esphome/voice-kit
      ref: dev
    components: [i2s_audio, nabu, voice_assistant, media_player, micro_wake_word]
    refresh: 0s

micro_wake_word:
  models:
    - model: okay_nabu
  vad:
  on_wake_word_detected:
    - if:
        condition:
          switch.is_off: master_mute_switch
        then:
          - if:
              condition:
                switch.is_on: timer_ringing
              then:
                - switch.turn_off: timer_ringing
                - micro_wake_word.start:
              else:
                - if:
                    condition:
                      lambda: return id(nabu_media_player)->state == media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING;
                    then:
                      lambda: |-
                        id(nabu_media_player)
                          ->make_call()
                          .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP)
                          .set_announcement(true)
                          .perform();
                - voice_assistant.start:
                    wake_word: !lambda return wake_word;
        else:
          - micro_wake_word.start:

voice_assistant:
  id: va
  microphone: kit_mic
  media_player: nabu_media_player
  use_wake_word: false
  noise_suppression_level: 0
  auto_gain: 0 dbfs
  volume_multiplier: 1
  on_client_connected:
    - wait_until:
        not: ble.enabled
    - lambda: id(init_in_progress) = false;
    - micro_wake_word.start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_client_disconnected:
    - micro_wake_word.stop:
    - voice_assistant.stop:
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: control_leds
  on_error:
    - if:
        condition:
          lambda: return !id(init_in_progress);
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};
          - script.execute: control_leds
          - delay: 1s
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
          - script.execute: control_leds
  on_start:
    - lambda: id(nabu_media_player).set_ducking_ratio(0.25);
  on_listening:
    - lambda: id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_end:
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: control_leds
  on_tts_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
    - script.execute: control_leds
  on_end:
    - wait_until:
        not:
          voice_assistant.is_running:
    - lambda: id(nabu_media_player).set_ducking_ratio(1.0);
    - micro_wake_word.start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_timer_finished:
    - switch.turn_on: timer_ringing

button:
  - platform: restart
    name: "Restart"
    entity_category: diagnostic

  - platform: factory_reset
    name: "Factory Reset"
    entity_category: diagnostic

  - platform: template
    name: "timer beep"
    entity_category: diagnostic
    on_press:
      - lambda: |-
          id(nabu_media_player)
            ->make_call()
            .set_announcement(true)
            .set_local_media_file(id(timer_finished_wave_file))
            .perform();

debug:
  update_interval: 5s
