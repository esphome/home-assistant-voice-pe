substitutions:
  # Phases of the Voice Assistant
  # The voice assistant is ready to be triggered by a wake word
  voice_assist_idle_phase_id: '1'
  # The voice assistant is waiting for a voice command (after being triggered by the wake word)
  voice_assist_waiting_for_command_phase_id: '2'
  # The voice assistant is listening for a voice command
  voice_assist_listening_for_command_phase_id: '3'
  # The voice assistant is currently processing the command
  voice_assist_thinking_phase_id: '4'
  # The voice assistant is replying to the command
  voice_assist_replying_phase_id: '5'
  # The voice assistant is not ready
  voice_assist_not_ready_phase_id: '10'
  # The voice assistant encountered an error
  voice_assist_error_phase_id: '11'

esphome:
  name: esphome-voice-kit
  friendly_name: ESPHome Voice Kit
  name_add_mac_suffix: true
  platformio_options:
    board_build.flash_mode: dio
  project:
    name: esphome.voice-kit
    version: dev
  on_boot:
    priority: 600
    then:
      # If the hardware switch is ON, force the software switch to be ON too. This covers the case where the Mute hardware switch is operated when the device is turned off
      - if:
          condition:
            binary_sensor.is_on: hardware_mute_switch
          then:
            - switch.template.publish:
                id: master_mute_switch
                state: ON
      # Run the script to refresh the LED status
      - script.execute: control_leds
      # If after 10 minutes, the device is still initializing (It did not yet connect to Home Assistant), turn off the init_in_progress variable and run the script to refresh the LED status
      - delay: 10min
      - if:
          condition:
            lambda: return id(init_in_progress);
          then:
            - lambda: id(init_in_progress) = false;
            - script.execute: control_leds

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32_S3_BOX_BOARD: "y"
      CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY: "y"
      # CONFIG_FREERTOS_USE_TRACE_FACILITY: "y"
      # CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS: "y"

wifi:
  ap:
  on_connect:
    - script.execute: control_leds
    - delay: 5s  # Gives time for improv results to be transmitted
    - ble.disable:
    - script.execute: control_leds
  on_disconnect:
    - ble.enable:
    - script.execute: control_leds

logger:
  level: DEBUG
  logs:
    sensor: WARN  # avoids logging debug sensor updates

api:
  on_client_connected:
    - script.execute: control_leds
  on_client_disconnected:
    - script.execute: control_leds

ota:
  - platform: esphome
    id: ota_esphome
  - platform: http_request
    id: ota_http_request

http_request:

update:
  - platform: http_request
    name: None
    id: update_http_request
    source: https://esphome.github.io/voice-kit/manifest.json

improv_serial:

esp32_improv:
  authorizer: center_button

i2c:
  sda: GPIO5
  scl: GPIO6

psram:
  mode: octal
  speed: 80MHz

globals:
  # Global index for our LEDs. So that switching between different animation does not lead to unwanted effects.
  - id: global_led_animation_index
    type: int
    restore_value: no
    initial_value: '0'
  # Global initialization variable. Initialized to true and set to false once everything is connected. Only used to have a smooth "plugging" experience
  - id: init_in_progress
    type: bool
    restore_value: no
    initial_value: 'true'
  # Global variable tracking the phase of the voice assistant (defined above). Initialized to not_ready
  - id: voice_assistant_phase
    type: int
    restore_value: no
    initial_value: ${voice_assist_not_ready_phase_id}
  # Global variable tracking if the dial was recently touched.
  - id: dial_touched
    type: bool
    restore_value: no
    initial_value: 'false'

switch:
  # This is the master mute switch. It is exposed to Home Assistant. The user can only turn it on and off if the hardware switch is off. (The hardware switch overrides the software one)
  - platform: template
    id: master_mute_switch
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:microphone-off"
    name: Mute
    entity_category: config
    turn_on_action:
      - if:
          condition:
            binary_sensor.is_off: hardware_mute_switch
          then:
            - switch.template.publish:
                id: master_mute_switch
                state: ON
    turn_off_action:
      - if:
          condition:
            binary_sensor.is_off: hardware_mute_switch
          then:
            - switch.template.publish:
                id: master_mute_switch
                state: OFF
    on_turn_on:
      - script.execute: control_leds
    on_turn_off:
      - script.execute: control_leds
  # Internal switch to track when a timer is ringing on the device.
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      - delay: 200ms
      - lambda: id(nabu_media_player).set_ducking_ratio(1);
      - script.execute: control_leds
    on_turn_on:
      - lambda: id(nabu_media_player).set_ducking_ratio(0.25);
      - script.execute: ring_timer
      - script.execute: control_leds
      - delay: 15min
      - switch.turn_off: timer_ringing

binary_sensor:
  # Center Button. Used for many things (See on_multi_click)
  - platform: gpio
    id: center_button
    pin:
      number: GPIO17
      inverted: true
    on_press:
      - script.execute: control_leds
    on_release:
      - script.execute: control_leds
    on_multi_click:
      # Simple Click:
      #   . Stops timer if a timer is ringing
      #   . Pauses music if music is playing
      #   . Resumes music if music is paused
      #   . Starts the voice assistant if it is not yet running and if the device is not muted.
      - timing:
          - ON for at most 1s
          - OFF for at least 0.5s
        then:
          - if:
              condition:
                switch.is_on: timer_ringing
              then:
                - switch.turn_off: timer_ringing
              else:
                - if:
                    condition:
                      media_player.is_playing:
                    then:
                      - media_player.pause:
                    else:
                      - if:
                          condition:
                            media_player.is_paused:
                          then:
                            - media_player.play:
                          else:
                            if:
                              condition:
                                and:
                                  - switch.is_off: master_mute_switch
                                  - not:
                                      voice_assistant.is_running
                              then:
                                - micro_wake_word.stop:
                                - voice_assistant.start:
      # Double Click
      #  . Exposed as an event entity. To be used in automations inside Home Assistant
      - timing:
          - ON for at most 1s
          - OFF for at most 0.5s
          - ON for at most 1s
          - OFF for at least 0.5s
        then:
          - event.trigger:
              id: button_press_event
              event_type: "double_press"
      # Triple Click
      #  . Exposed as an event entity. To be used in automations inside Home Assistant
      - timing:
          - ON for at most 1s
          - OFF for at most 0.5s
          - ON for at most 1s
          - OFF for at most 0.5s
          - ON for at most 1s
          - OFF for at least 0.5s
        then:
          - event.trigger:
              id: button_press_event
              event_type: "triple_press"
      # Long Press
      #  . Exposed as an event entity. To be used in automations inside Home Assistant
      - timing:
          - ON for at least 1s
        then:
          - if:
              condition:
                lambda: return !id(dial_touched);
              then:
                - light.turn_off: voice_assistant_leds
                - event.trigger:
                    id: button_press_event
                    event_type: "long_press"
      # Very important do not remove. Trust me :D
      - timing:
          # E .
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # S ...
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # P .--.
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # H ....
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # O ---
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0.5s to 2s
          # M --
          - ON for 0.2s to 2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
          - OFF for 0.5s to 2s
          # E .
          - ON for at most 0.2s
          - OFF for at least 0.5s
        then:
          - light.turn_on:
              brightness: 100%
              id: voice_assistant_leds
              effect: "Tick"
          - lambda: |-
              id(nabu_media_player)
                ->make_call()
                .set_announcement(true)
                .set_local_media_file(id(tick_wave_file))
                .perform();
          - delay: 4s
          - light.turn_off: voice_assistant_leds
          - lambda: |-
              id(nabu_media_player)
                ->make_call()
                .set_announcement(true)
                .set_local_media_file(id(party_wave_file))
                .perform();
          - light.turn_on:
              brightness: 100%
              id: voice_assistant_leds
              effect: "Rainbow"
      # Factory Reset Warning
      #  . Audible and Visible warning.
      - timing:
          - ON for at least 10s
        then:
          - if:
              condition:
                lambda: return !id(dial_touched);
              then:
                - light.turn_on:
                    brightness: 100%
                    id: voice_assistant_leds
                    effect: "Factory Reset Coming Up"
                - lambda: |-
                    id(nabu_media_player)
                      ->make_call()
                      .set_announcement(true)
                      .set_local_media_file(id(facotry_reset_initiated_wave_file))
                      .perform();
                - wait_until:
                    binary_sensor.is_off: center_button
                - light.turn_off: voice_assistant_leds
                - lambda: |-
                    id(nabu_media_player)
                      ->make_call()
                      .set_announcement(true)
                      .set_local_media_file(id(facotry_reset_cancelled_wave_file))
                      .perform();
      # Factory Reset
      - timing:
          - ON for at least 22s
        then:
          - if:
              condition:
                lambda: return !id(dial_touched);
              then:
                - button.press: factory_reset_button
  # Hardware mute switch (Side of the device)
  - platform: gpio
    id: hardware_mute_switch
    internal: true
    pin: GPIO3
    on_press:
      - switch.template.publish:
          id: master_mute_switch
          state: ON
    on_release:
      - switch.template.publish:
          id: master_mute_switch
          state: OFF

light:
  # Hardware LED ring. Not used because remapping needed
  - platform: esp32_rmt_led_strip
    id: leds_internal
    pin: GPIO21
    rmt_channel: 1
    num_leds: 12
    rgb_order: GRB
    chipset: WS2812
    default_transition_length: 0ms
    power_supply: led_power

  # Voice Assistant LED ring. Remapping of the internal LED.
  # This light is not exposed. The device controls it
  - platform: partition
    id: voice_assistant_leds
    internal: true
    default_transition_length: 0ms
    segments:
      - id: leds_internal
        from: 7
        to: 11
      - id: leds_internal
        from: 0
        to: 6
    effects:
      - addressable_lambda:
          name: "Waiting for Command"
          update_interval: 100ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 11) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 10) % 12) {
                it[i] = color * 128;
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 5) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 4) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 12;
      - addressable_lambda:
          name: "Listening For Command"
          update_interval: 50ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 11) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 10) % 12) {
                it[i] = color * 128;
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 5) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 4) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 12;
      - addressable_lambda:
          name: "Thinking"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
              } else {
                it[i] = Color::BLACK;
              }
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Replying"
          update_interval: 50ms
          lambda: |-
            id(global_led_animation_index) = (12 + id(global_led_animation_index) - 1) % 12;
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == (id(global_led_animation_index)) % 12) {
                it[i] = color;
              } else if (i == ( id(global_led_animation_index) + 1) % 12) {
                it[i] = color * 192;
              } else if (i == ( id(global_led_animation_index) + 2) % 12) {
                it[i] = color * 128;
              } else if (i == ( id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == ( id(global_led_animation_index) + 7) % 12) {
                it[i] = color * 192;
              } else if (i == ( id(global_led_animation_index) + 8) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Muted"
          update_interval: 16ms
          lambda: |-
            static int8_t index = 0;
            Color color(255, 0, 0);
            for (int i = 0; i < 12; i++) {
              if (i == 2) {
                it[i] = color;
              } else if (i == 3) {
                it[i] = color;
              } else if (i == 8) {
                it[i] = color;
              } else if (i == 9) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Volume Display"
          update_interval: 50ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            auto nb_leds_on = 12.0f * id(nabu_media_player).volume;
            for (int i = 0; i < 12; i++) {
              if (i < nb_leds_on) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Center Button Touched"
          update_interval: 16ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              it[i] = color;
            }
      - addressable_twinkle:
          name: "Twinkle"
          twinkle_probability: 50%
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%
      - addressable_lambda:
          name: "Timer Ring"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_rainbow:
          name: "Rainbow"
          width: 12
      - addressable_lambda:
          name: "Tick"
          update_interval: 333ms
          lambda: |-
            static uint8_t index = 0;
            Color color(255, 0, 0);
            if (initial_run) {
              index = 0;
            }
            for (int i = 0; i < 12; i++) {
              if (i <= index ) {
                it[i] = Color::BLACK;
              } else {
                it[i] = color;
              }
            }
            index = (index + 1) % 12;
      - addressable_lambda:
          name: "Factory Reset Coming Up"
          update_interval: 1s
          lambda: |-
            static uint8_t index = 0;
            Color color(255, 0, 0);
            if (initial_run) {
              index = 0;
            }
            for (int i = 0; i < 12; i++) {
              if (i <= index ) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
            index = (index + 1) % 12;

  # User facing LED ring. Remapping of the internal LEDs.
  # Exposed to be used by the user.
  - platform: partition
    id: led_ring
    name: LED Ring
    entity_category: config
    icon: "mdi:circle-outline"
    default_transition_length: 0ms
    restore_mode: RESTORE_DEFAULT_OFF
    segments:
      - id: leds_internal
        from: 7
        to: 11
      - id: leds_internal
        from: 0
        to: 6

power_supply:
  - id: led_power
    pin: GPIO45

sensor:
  # The dial. Used to control volume and Hue of the LED ring.
  - platform: rotary_encoder
    id: dial
    pin_a: GPIO16
    pin_b: GPIO18
    resolution: 2
    on_clockwise:
      - lambda: id(dial_touched) = true;
      - if:
          condition:
            binary_sensor.is_off: center_button
          then:
            - script.execute:
                id: control_volume
                increase_volume: true
            - if:
                condition:
                  lambda: return(id(dial).state > 120);
                then:
                  - sensor.rotary_encoder.set_value:
                      id: dial
                      value: 0
                  - lambda: |-
                      id(nabu_media_player)
                        ->make_call()
                        .set_announcement(true)
                        .set_local_media_file(id(rewind_wave_file))
                        .perform();
          else:
            - script.execute:
                id: control_hue
                increase_hue: true
    on_anticlockwise:
      - lambda: id(dial_touched) = true;
      - if:
          condition:
            binary_sensor.is_off: center_button
          then:
            - script.execute:
                id: control_volume
                increase_volume: false
          else:
            - script.execute:
                id: control_hue
                increase_hue: false

  # To be removed before launch
  - platform: debug
    free:
      name: "Heap Free"
    block:
      name: "Max Block Free"
    loop_time:
      name: "Loop Time"
    psram:
      name: "PSRAM Free"

event:
  # Event entity exposed to the user to automate on complex center button presses.
  # The simple press is not exposed as it is used to control the device itself.
  - platform: template
    id: button_press_event
    name: "Button press"
    icon: mdi:button-pointer
    device_class: button
    event_types:
      - double_press
      - triple_press
      - long_press

script:
  # Master script controlling the LEDs, based on different conditions : initialization in progress, wifi and api connected and voice assistant phase.
  # For the sake of simplicity and re-usability, the script calls child scripts defined below.
  # This script will be called every time one of these conditions is changing.
  - id: control_leds
    then:
      - if:
          condition:
            lambda: return !id(init_in_progress);
          then:
            - if:
                condition:
                  wifi.connected:
                then:
                  - if:
                      condition:
                        api.connected:
                      then:
                        - if:
                            condition:
                              binary_sensor.is_off: center_button
                            then:
                              - if:
                                  condition:
                                    lambda: return !id(dial_touched);
                                  then:
                                    - if:
                                        condition:
                                          switch.is_off: timer_ringing
                                        then:
                                          - if:
                                              condition:
                                                switch.is_off: master_mute_switch
                                              then:
                                                - lambda: |
                                                    switch(id(voice_assistant_phase)) {
                                                      case ${voice_assist_waiting_for_command_phase_id}:
                                                        id(control_leds_voice_assistant_waiting_for_command_phase).execute();
                                                        break;
                                                      case ${voice_assist_listening_for_command_phase_id}:
                                                        id(control_leds_voice_assistant_listening_for_command_phase).execute();
                                                        break;
                                                      case ${voice_assist_thinking_phase_id}:
                                                        id(control_leds_voice_assistant_thinking_phase).execute();
                                                        break;
                                                      case ${voice_assist_replying_phase_id}:
                                                        id(control_leds_voice_assistant_replying_phase).execute();
                                                        break;
                                                      case ${voice_assist_error_phase_id}:
                                                        id(control_leds_voice_assistant_error_phase).execute();
                                                        break;
                                                      case ${voice_assist_not_ready_phase_id}:
                                                        id(control_leds_voice_assistant_not_ready_phase).execute();
                                                        break;
                                                      default:
                                                        id(control_leds_voice_assistant_idle_phase).execute();
                                                        break;
                                                    }
                                              else:
                                                - script.execute: control_leds_muted
                                        else:
                                          - script.execute: control_leds_timer_ringing
                                  else:
                                    - script.execute: control_leds_dial_touched
                            else:
                              - script.execute: control_leds_center_button_touched
                      else:
                        - script.execute: control_leds_no_ha_connection_state
                else:
                  - script.execute: control_leds_no_ha_connection_state
          else:
            - script.execute: control_leds_init_state

  # Script executed during initialization
  # Blue Twinkle if Wifi is not connected
  # Green Twinkle if Wifi is connected
  - id: control_leds_init_state
    then:
      - if:
          condition:
            not: wifi.connected
          then:
            - light.turn_on:
                brightness: 100%
                red: 0
                green: 0
                blue: 1.0
                id: voice_assistant_leds
                effect: "Twinkle"
          else:
            - light.turn_on:
                brightness: 100%
                red: 0
                green: 1.0
                blue: 0
                id: voice_assistant_leds
                effect: "Twinkle"

  # Script executed when the device has no connection to Home Assistant
  # Red Twinkle (This will be visible during HA updates for example)
  - id: control_leds_no_ha_connection_state
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Twinkle"

  # Script executed when the voice assistant is idle (waiting for a wake word)
  # Nothing (Either LED ring off or LED ring on if the user decided to turn the user facing LED ring on)
  - id: control_leds_voice_assistant_idle_phase
    then:
      - light.turn_off: voice_assistant_leds
      - if:
          condition:
            light.is_on: led_ring
          then:
            light.turn_on: led_ring

  # Script executed when the voice assistant is waiting for a command (After the wake word)
  # Slow clockwise spin of the LED ring.
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Waiting for Command"

  # Script executed when the voice assistant is listening to a command
  # Fast clockwise spin of the LED ring.
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Listening For Command"

  # Script executed when the voice assistant is thinking to a command
  # The spin stops and the 2 LEDs that are currently on and blinking indicating the commend is being processed.
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Thinking"

  # Script executed when the voice assistant is thinking to a command
  # Fast anticlockwise spin of the LED ring.
  - id: control_leds_voice_assistant_replying_phase
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Replying"

  # Script executed when the voice assistant is in error
  # Fast Red Pulse
  # Note: Today on_end happens too fast after an error. This is barely visible.
  - id: control_leds_voice_assistant_error_phase
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Fast Pulse"

  # Script executed when the voice assistant is muted
  # The LED next to the 2 microphones turn red.
  - id: control_leds_muted
    then:
      - light.turn_on:
          brightness: 50%
          id: voice_assistant_leds
          effect: "Muted"

  # Script executed when the voice assistant is not ready
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Twinkle"

  # Script executed when the dial is touched
  # A number of LEDs turn on indicating a visual representation of the volume of the media player entity.
  - id: control_leds_dial_touched
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Volume Display"

  # Script executed when the center button is touched
  # The complete LED ring turns on
  - id: control_leds_center_button_touched
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Center Button Touched"

  # Script executed when the timer is ringing, to control the LEDs
  # The LED ring blinks.
  - id: control_leds_timer_ringing
    then:
      - light.turn_on:
          brightness: 100%
          id: voice_assistant_leds
          effect: "Timer Ring"

  # Script executed when the volume is increased/decreased from the dial
  - id: control_volume
    mode: restart
    parameters:
      increase_volume: bool  # True: Increase volume / False: Decrease volume.
    then:
      - delay: 16ms
      - if:
          condition:
            lambda: return increase_volume;
          then:
            - media_player.volume_up:
          else:
            - media_player.volume_down:
      - script.execute: control_leds
      - delay: 2s
      - lambda: id(dial_touched) = false;
      - script.execute: control_leds
      - sensor.rotary_encoder.set_value:
          id: dial
          value: 0

  # Script executed when the hue is increased/decreased from the dial
  - id: control_hue
    mode: restart
    parameters:
      increase_hue: bool  # True: Increase volume / False: Decrease volume.
    then:
      - delay: 16ms
      - lambda: |
          auto light_color = id(led_ring).current_values;
          int hue = 0;
          float saturation = 0;
          float value = 0;
          rgb_to_hsv( light_color.get_red(),
                      light_color.get_green(),
                      light_color.get_blue(),
                      hue,
                      saturation,
                      value);
          if (increase_hue) {
            hue = (hue + 10) % 360;
          } else {
            hue = (hue + 350) % 360;
          }
          if (saturation < 0.05) {
            saturation = 1;
          }
          float red = 0;
          float green = 0;
          float blue = 0;
          hsv_to_rgb( hue,
                      saturation,
                      value,
                      red,
                      green,
                      blue);
          id(led_ring).make_call().set_rgb(red, green, blue).perform();
      - sensor.rotary_encoder.set_value:
          id: dial
          value: 0
      - wait_until:
          binary_sensor.is_off: center_button
      - lambda: id(dial_touched) = false;
      - script.execute: control_leds

  # Script executed when the timer is ringing, to playback sounds.
  - id: ring_timer
    then:
      - while:
          condition:
            switch.is_on: timer_ringing
          then:
            - lambda: |-
                id(nabu_media_player)
                  ->make_call()
                  .set_announcement(true)
                  .set_local_media_file(id(timer_finished_wave_file))
                  .perform();
            - delay: 1s

i2s_audio:
  - id: i2s_input
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:
      number: GPIO9
      allow_other_uses: true
    i2s_mode: secondary

  - id: i2s_output
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:
      number: GPIO9
      allow_other_uses: true
    i2s_mode: secondary
    # i2s_output data pin is gpio10

  # yamllint disable rule:comments-indentation
  # This describes the second I2S interface between ESP32 and XMOS chip. Currently unused.
  # - id: i2s_output
  #   i2s_lrclk_pin:
  #     number: GPIO14
  #     # allow_other_uses: true
  #   i2s_bclk_pin:
  #     number: GPIO13
  #     # allow_other_uses: true
  #   i2s_mclk_pin:
  #     number: GPIO12
  #     # allow_other_uses: true
  #   i2s_mode: primary #secondary
  # data line is GPIO15
  # yamllint enable rule:comments-indentation

microphone:
  - platform: i2s_audio
    id: kit_mic
    i2s_din_pin: GPIO11
    adc_type: external
    pdm: false
    bits_per_sample: 32bit
    channel: left
    i2s_audio_id: i2s_input

media_player:
  - platform: nabu
    id: nabu_media_player
    name: Media Player
    internal: false
    i2s_dout_pin: GPIO10
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    files:
      - id: timer_finished_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/timer_finished.wav
      - id: tick_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/tick.wav
      - id: party_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/party.wav
      - id: rewind_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/rewind.wav
      - id: awake_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/awake.wav
      - id: facotry_reset_initiated_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/facotry_reset_initiated.wav
      - id: facotry_reset_cancelled_wave_file
        file: https://github.com/esphome/voice-kit/raw/dev/sounds/facotry_reset_cancelled.wav

external_components:
  - source: github://jesserockz/esphome-components
    components: [file, udp_audio]
    refresh: 0s

  - source:
      type: git
      url: https://github.com/esphome/voice-kit
      ref: kahrendt-20240805-audio-in
    components: [i2s_audio, microphone, nabu, voice_assistant, media_player, micro_wake_word]
    refresh: 0s

  - source: github://esphome/esphome@dev
    components: [update, http_request, watchdog]
    refresh: 0s

micro_wake_word:
  models:
    - model: okay_nabu
      id: okay_nabu
    - model: hey_jarvis
      id: hey_jarvis
    - model: hey_mycroft
      id: hey_mycroft
  vad:
  on_wake_word_detected:
    # If the wake word is detected when the device is muted (Possible with the software mute switch): Do nothing (Just restart micro wake word)
    - if:
        condition:
          switch.is_off: master_mute_switch
        then:
          # If a timer is ringing: Stop it, do not start the voice assistant, restart micro wake word (We can stop timer from voice!)
          - if:
              condition:
                switch.is_on: timer_ringing
              then:
                - switch.turn_off: timer_ringing
                - micro_wake_word.start:
              # Start voice assistant, stop current announcement.
              else:
                - if:
                    condition:
                      lambda: return id(nabu_media_player)->state == media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING;
                    then:
                      lambda: |-
                        id(nabu_media_player)
                          ->make_call()
                          .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP)
                          .set_announcement(true)
                          .perform();
                - voice_assistant.start:
                    wake_word: !lambda return wake_word;
        else:
          - micro_wake_word.start:

select:
  - platform: template
    name: "Wake word select"
    options:
      - "OK Nabu"
      - "Hey Jarvis"
      - "Hey Mycroft"
    optimistic: true
    on_value:
      then:
        - lambda: |-
            if (x == "OK Nabu") {
              id(okay_nabu).enable();
              id(hey_mycroft).disable();
              id(hey_jarvis).disable();
            } else if (x == "Hey Mycroft") {
              id(okay_nabu).disable();
              id(hey_mycroft).enable();
              id(hey_jarvis).disable();
            } else if (x == "Hey Jarvis") {
              id(okay_nabu).disable();
              id(hey_mycroft).disable();
              id(hey_jarvis).enable();
            }

voice_assistant:
  id: va
  microphone: kit_mic
  media_player: nabu_media_player
  use_wake_word: false
  noise_suppression_level: 0
  auto_gain: 0 dbfs
  volume_multiplier: 1
  on_client_connected:
    - wait_until:
        not: ble.enabled
    - lambda: id(init_in_progress) = false;
    - micro_wake_word.start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_client_disconnected:
    - micro_wake_word.stop:
    - voice_assistant.stop:
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: control_leds
  on_error:
    - if:
        condition:
          lambda: return !id(init_in_progress);
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};
          - script.execute: control_leds
          - delay: 1s
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
          - script.execute: control_leds
  # When the voice assistant starts: Play a wake up sound, duck audio.
  on_start:
    - lambda: |-
        id(nabu_media_player)
          ->make_call()
          .set_announcement(true)
          .set_local_media_file(id(awake_wave_file))
          .perform();
    - lambda: id(nabu_media_player).set_ducking_ratio(0.25);
  on_listening:
    - lambda: id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_end:
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: control_leds
  on_tts_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
    - script.execute: control_leds
  # When the voice assistant ends: Stop ducking audio.
  on_end:
    - wait_until:
        not:
          voice_assistant.is_running:
    - lambda: id(nabu_media_player).set_ducking_ratio(1.0);
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_timer_finished:
    - switch.turn_on: timer_ringing

button:
  # TODO: Remove before launch, added for testing/development
  - platform: restart
    name: "Restart"
    entity_category: diagnostic

  # TODO: make it internal before launch
  - platform: factory_reset
    id: factory_reset_button
    name: "Factory Reset"
    entity_category: diagnostic

  # TODO: Remove before launch, added for testing/development
  - platform: template
    name: "timer beep"
    entity_category: diagnostic
    on_press:
      - lambda: |-
          id(nabu_media_player)
            ->make_call()
            .set_announcement(true)
            .set_local_media_file(id(timer_finished_wave_file))
            .perform();

  # TODO: Remove before launch, added for testing/development
  - platform: template
    name: Check for update
    entity_category: diagnostic
    on_press:
      - component.update: update_http_request

  # TODO: Remove before launch, added for testing/development
  - platform: template
    name: Perform Update
    entity_category: diagnostic
    on_press:
      - update.perform:
          id: update_http_request
          force_update: true

debug:
  update_interval: 5s
